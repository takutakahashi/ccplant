# スケジュール実行

## 概要

スケジュール機能を使用すると、Cron 式に基づいて定期的にセッションを起動し、AI エージェントに自動的にタスクを実行させることができます。毎日のレポート生成、定期的なコードチェック、自動バックアップなど、様々な定期タスクを自動化できます。

## スケジュールとは

スケジュールは、指定した時刻またはパターンで自動的にセッションを起動する機能です。

**基本的な流れ:**
```
スケジュールワーカー起動
    ↓
Cron 式を評価
    ↓
実行時刻に到達
    ↓
新規セッション作成
    ↓
AI エージェントがタスク実行
    ↓
セッション完了
    ↓
次回実行時刻を計算
```

## Cron 式の基本

### Cron 式の構文

```
┌───────────── 分 (0 - 59)
│ ┌─────────── 時 (0 - 23)
│ │ ┌───────── 日 (1 - 31)
│ │ │ ┌─────── 月 (1 - 12)
│ │ │ │ ┌───── 曜日 (0 - 6) (0: 日曜日)
│ │ │ │ │
* * * * *
```

### よく使うパターン

| Cron 式 | 実行タイミング | 説明 |
|---------|--------------|------|
| `0 9 * * *` | 毎日 9:00 | 毎朝の定期タスク |
| `*/30 * * * *` | 30分ごと | 頻繁なチェック |
| `0 0 * * 0` | 毎週日曜 0:00 | 週次レポート |
| `0 0 1 * *` | 毎月 1日 0:00 | 月次処理 |
| `0 */2 * * *` | 2時間ごと | 定期モニタリング |
| `0 9 * * 1-5` | 平日 9:00 | ビジネスアワー |
| `0 22 * * *` | 毎日 22:00 | 夜間バッチ |

### 特殊な記号

| 記号 | 意味 | 例 |
|-----|------|-----|
| `*` | すべての値 | `* * * * *` = 毎分 |
| `,` | 複数の値 | `0 9,12,15 * * *` = 9時、12時、15時 |
| `-` | 範囲指定 | `0 9 * * 1-5` = 平日 |
| `/` | 間隔指定 | `*/15 * * * *` = 15分ごと |

## スケジュールの作成

### Web UI から作成

1. ダッシュボードで「スケジュール」タブを開く
2. 「新規スケジュール」ボタンをクリック
3. スケジュール設定を入力:

**基本設定:**
```
名前: 毎日のコードレビュー
説明: 前日のコミットをレビューします
有効: ✓
```

**スケジュール設定:**
```
Cron 式: 0 9 * * 1-5
タイムゾーン: Asia/Tokyo
次回実行: 2024-01-28 09:00:00
```

**セッション設定:**
```
エージェント: code-reviewer
メッセージ:
---
昨日のコミットをレビューしてください。
以下の点を確認:
1. コード品質
2. テストカバレッジ
3. ドキュメント更新
---
```

4. 「作成」をクリック

**スクリーンショットの説明:**
スケジュール作成フォームには、名前入力欄、Cron 式エディタ (視覚的な時刻選択とテキスト入力の両方)、次回実行時刻のプレビュー、メッセージエディタが表示されます。

### API から作成

```bash
curl -X POST https://cc-api.example.com/api/v1/schedules \
  -H "Authorization: Bearer ${GITHUB_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "daily-code-review",
    "description": "Review yesterday commits",
    "enabled": true,
    "cron_expression": "0 9 * * 1-5",
    "timezone": "Asia/Tokyo",
    "session_config": {
      "agent_id": "code-reviewer",
      "message": "昨日のコミットをレビューしてください。"
    }
  }'
```

**レスポンス:**
```json
{
  "schedule_id": "schedule-123",
  "name": "daily-code-review",
  "cron_expression": "0 9 * * 1-5",
  "next_run": "2024-01-28T09:00:00+09:00",
  "enabled": true,
  "created_at": "2024-01-27T12:00:00Z"
}
```

## スケジュール管理

### スケジュール一覧の表示

Web UI のダッシュボードで、すべてのスケジュールを確認できます。

**表示される情報:**
- スケジュール名
- 有効/無効ステータス
- Cron 式
- 次回実行時刻
- 最終実行日時
- 最終実行結果 (成功/失敗)

**スクリーンショットの説明:**
スケジュール一覧は、カード形式で表示されます。各カードには、スケジュール名、緑色または灰色のステータストグル、Cron 式、大きく表示された次回実行時刻、「編集」「削除」ボタンが含まれます。

### 次回実行時刻の表示

次回実行時刻は、以下の形式で表示されます:

**絶対時刻:**
```
次回実行: 2024-01-28 09:00:00 (JST)
```

**相対時刻:**
```
次回実行: 12時間後
```

マウスホバーで、両方の形式が表示されます。

### スケジュールの有効化/無効化

スケジュールは、削除せずに一時的に無効化できます。

**Web UI:**
1. スケジュール一覧で対象のスケジュールを見つける
2. スケジュールカードのトグルスイッチをクリック
3. 即座に有効/無効が切り替わる

**API:**
```bash
# 無効化
curl -X PATCH https://cc-api.example.com/api/v1/schedules/{schedule_id} \
  -H "Authorization: Bearer ${GITHUB_TOKEN}" \
  -d '{"enabled": false}'

# 有効化
curl -X PATCH https://cc-api.example.com/api/v1/schedules/{schedule_id} \
  -H "Authorization: Bearer ${GITHUB_TOKEN}" \
  -d '{"enabled": true}'
```

**スクリーンショットの説明:**
トグルスイッチは、有効時は青色、無効時は灰色で表示されます。クリックすると滑らかにアニメーションします。

### スケジュールの編集

1. スケジュール一覧で編集したいスケジュールを見つける
2. 「編集」ボタンをクリック
3. 設定を変更
4. 「保存」をクリック

**編集可能な項目:**
- 名前
- 説明
- Cron 式
- タイムゾーン
- 有効/無効
- メッセージ
- セッション設定

**注意:**
Cron 式を変更すると、次回実行時刻が再計算されます。

### スケジュールの削除

1. スケジュール一覧で削除したいスケジュールを見つける
2. 「削除」ボタンをクリック
3. 確認ダイアログで「削除」をクリック

**注意:**
- 削除すると、そのスケジュールは二度と実行されません
- 実行履歴は保持されます

## 実行履歴

各スケジュールの実行履歴を確認できます。

### 履歴の表示

1. スケジュール詳細画面を開く
2. 「実行履歴」タブをクリック

**表示される情報:**
- 実行日時
- ステータス (成功/失敗)
- 実行時間
- 作成されたセッション ID (リンク)
- エラーメッセージ (失敗時)

**スクリーンショットの説明:**
実行履歴は、テーブル形式で表示されます。成功した実行は緑色のチェックマーク、失敗した実行は赤色のエラーアイコンで示されます。

### 履歴のフィルタリング

```bash
# 成功した実行のみ
GET /api/v1/schedules/{schedule_id}/history?status=success

# 失敗した実行のみ
GET /api/v1/schedules/{schedule_id}/history?status=failed

# 期間指定
GET /api/v1/schedules/{schedule_id}/history?from=2024-01-01&to=2024-01-31
```

## Leader Election によるワーカー管理

ccplant は複数の agentapi-proxy インスタンスで構成できます。スケジュール実行が重複しないよう、Leader Election を使用します。

### Leader Election の仕組み

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Instance 1  │  │ Instance 2  │  │ Instance 3  │
│  (Leader)   │  │ (Follower)  │  │ (Follower)  │
└──────┬──────┘  └─────────────┘  └─────────────┘
       │
       ▼
  スケジュール実行
```

**動作:**
1. 各インスタンスが Leader 選出に参加
2. Kubernetes の Lease リソースを使用
3. Leader のみがスケジュールを実行
4. Leader に障害が発生すると、自動的に新しい Leader が選出される

### Lease リソース

```bash
# Leader Election の状態を確認
kubectl get lease ccplant-schedule-leader -o yaml

# 出力例
metadata:
  name: ccplant-schedule-leader
spec:
  holderIdentity: ccplant-agentapi-proxy-7d8c9f5b4-abcde
  leaseDurationSeconds: 15
  renewTime: "2024-01-27T12:00:00Z"
```

**フィールドの説明:**
- `holderIdentity`: 現在の Leader (Pod 名)
- `leaseDurationSeconds`: リースの有効期限
- `renewTime`: 最終更新日時

### フェイルオーバー

Leader に障害が発生した場合:

```
1. Leader の Pod がダウン
    ↓
2. Lease の更新が停止
    ↓
3. 15秒後にリースが失効
    ↓
4. Follower の1つが新しい Leader に
    ↓
5. スケジュール実行が再開
```

**ダウンタイム:** 最大 15 秒

## 実用例

### 例 1: 毎日のコードレビュー

**目的:** 前日のコミットを毎朝レビュー

**設定:**
```yaml
name: "daily-code-review"
cron_expression: "0 9 * * 1-5"  # 平日 9:00
timezone: "Asia/Tokyo"
message: |
  昨日のコミットをレビューしてください。

  以下の点を確認:
  1. コード品質とベストプラクティス
  2. テストカバレッジ
  3. ドキュメントの更新
  4. セキュリティの問題

  レビュー結果を Issue として報告してください。
```

### 例 2: 週次セキュリティスキャン

**目的:** 毎週日曜日にセキュリティスキャンを実行

**設定:**
```yaml
name: "weekly-security-scan"
cron_expression: "0 0 * * 0"  # 日曜 0:00
message: |
  セキュリティスキャンを実行してください。

  実行するスキャン:
  1. 依存関係の脆弱性チェック
  2. コードの静的解析
  3. シークレットスキャン
  4. ライセンスコンプライアンス

  結果をレポートとしてまとめてください。
```

### 例 3: 定期的なバックアップ

**目的:** 毎晩データベースのバックアップを実行

**設定:**
```yaml
name: "nightly-backup"
cron_expression: "0 2 * * *"  # 毎日 2:00
message: |
  以下のバックアップを実行してください:

  1. データベースのダンプ
  2. S3 へのアップロード
  3. 古いバックアップの削除 (30日以上前)
  4. バックアップの検証

  結果を Slack に通知してください。
```

### 例 4: 定期的なパフォーマンステスト

**目的:** 毎時パフォーマンスをチェック

**設定:**
```yaml
name: "hourly-performance-test"
cron_expression: "0 * * * *"  # 毎時 0分
message: |
  パフォーマンステストを実行してください。

  テスト項目:
  1. API レスポンスタイム
  2. データベースクエリ速度
  3. メモリ使用量
  4. CPU 使用率

  異常があれば通知してください。
```

## トラブルシューティング

### スケジュールが実行されない

**確認項目:**

1. **スケジュールが有効か**
   ```bash
   # Web UI または API で確認
   curl https://cc-api.example.com/api/v1/schedules/{schedule_id}
   ```

2. **Cron 式が正しいか**
   - Cron 式をオンラインツールで検証
   - タイムゾーンが正しいか確認

3. **Leader Election の状態**
   ```bash
   kubectl get lease ccplant-schedule-leader
   ```

4. **ログの確認**
   ```bash
   kubectl logs -f deployment/ccplant-agentapi-proxy | grep schedule
   ```

### 実行が遅延する

**原因:**
- リソース不足
- 多数のスケジュールが同時実行

**対処:**
1. クラスターのリソースを確認
2. スケジュールの実行時刻を分散
3. レプリカ数を増やす

### 重複実行される

**原因:**
- Leader Election が正しく動作していない

**対処:**
```bash
# Lease リソースを確認
kubectl get lease ccplant-schedule-leader -o yaml

# 必要に応じて Lease を削除して再作成
kubectl delete lease ccplant-schedule-leader
```

## ベストプラクティス

### 1. 適切な実行間隔を設定

```
✓ タスクに応じた適切な間隔
✓ リソース使用を考慮
✓ ピーク時間を避ける

✗ 過度に頻繁な実行
✗ すべてのスケジュールを同じ時刻に設定
```

### 2. タイムゾーンを明示

```yaml
# 推奨: タイムゾーンを明示
timezone: "Asia/Tokyo"

# 非推奨: UTC を想定
# (混乱の原因になる)
```

### 3. エラーハンドリングを含める

メッセージに、エラー時の対応を含めます:

```
実行中にエラーが発生した場合:
1. エラーメッセージを記録
2. Slack に通知
3. 次回実行で再試行
```

### 4. リソース制限を設定

長時間実行されるタスクには、タイムアウトを設定:

```yaml
session_config:
  timeout_minutes: 30
```

### 5. 通知を設定

スケジュール実行の成功/失敗を通知:

```yaml
notifications:
  on_success: false
  on_failure: true
  channels: ["email", "slack"]
```

## まとめ

スケジュール機能により、定期的なタスクを自動化し、開発プロセスを効率化できます。Cron 式と適切な設定により、柔軟な自動化ワークフローを構築できます。

### 次のステップ

- [Webhook 統合](./webhooks.md) - イベント駆動の自動化
- [セッション管理](./sessions.md) - セッションの詳細設定
- [通知設定](./notifications.md) - 実行結果の通知

### 関連リソース

- [Cron 式ジェネレーター](https://crontab.guru/)
- [バックエンドスケジュール実装](../backend/webhooks-schedules.md)
- [Kubernetes Leader Election](https://kubernetes.io/docs/concepts/architecture/leases/)
